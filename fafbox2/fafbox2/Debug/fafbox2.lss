
fafbox2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  000002e2  00000376  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000002e2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000038b  00800102  00800102  00000378  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000378  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000003a8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c8  00000000  00000000  000003e8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000054d  00000000  00000000  000004b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002eb  00000000  00000000  000009fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000009ea  00000000  00000000  00000ce8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000e0  00000000  00000000  000016d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000272  00000000  00000000  000017b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000b3  00000000  00000000  00001a26  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000068  00000000  00000000  00001ad9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  34:	0c 94 5d 00 	jmp	0xba	; 0xba <__vector_13>
  38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d0 e1       	ldi	r29, 0x10	; 16
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	11 e0       	ldi	r17, 0x01	; 1
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	e2 ee       	ldi	r30, 0xE2	; 226
  90:	f2 e0       	ldi	r31, 0x02	; 2
  92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0
  98:	a2 30       	cpi	r26, 0x02	; 2
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
  9e:	24 e0       	ldi	r18, 0x04	; 4
  a0:	a2 e0       	ldi	r26, 0x02	; 2
  a2:	b1 e0       	ldi	r27, 0x01	; 1
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	ad 38       	cpi	r26, 0x8D	; 141
  aa:	b2 07       	cpc	r27, r18
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
  ae:	0e 94 69 01 	call	0x2d2	; 0x2d2 <main>
  b2:	0c 94 6f 01 	jmp	0x2de	; 0x2de <_exit>

000000b6 <__bad_interrupt>:
  b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <__vector_13>:
.global TIMER1_COMPA_vect
TIMER1_COMPA_vect:

	//horizontal sync porch - 96 cycles

	push r16 ;2
  ba:	0f 93       	push	r16

	in r16, _SFR_IO_ADDR(SREG) ;1
  bc:	0f b7       	in	r16, 0x3f	; 63
	push r16 ;2
  be:	0f 93       	push	r16

	//adjust interrupt response time

	lds r16, _SFR_MEM_ADDR(TCNT1L) ;2
  c0:	00 91 84 00 	lds	r16, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
	cpi r16, 16 ;1
  c4:	00 31       	cpi	r16, 0x10	; 16
	breq sixteen ;1/2
  c6:	41 f0       	breq	.+16     	; 0xd8 <sixteen>
	cpi r16, 15 ;1
  c8:	0f 30       	cpi	r16, 0x0F	; 15
	breq fifteen ;1/2
  ca:	39 f0       	breq	.+14     	; 0xda <fifteen>
	cpi r16, 14 ;1
  cc:	0e 30       	cpi	r16, 0x0E	; 14
	breq fourteen ;1/2
  ce:	31 f0       	breq	.+12     	; 0xdc <fourteen>
	cpi r16, 13 ;1
  d0:	0d 30       	cpi	r16, 0x0D	; 13
	breq thirteen ;1/2
  d2:	29 f0       	breq	.+10     	; 0xde <thirteen>
	cpi r16, 12 ;1
  d4:	0c 30       	cpi	r16, 0x0C	; 12
	breq twelve ;1/2
  d6:	21 f0       	breq	.+8      	; 0xe0 <twelve>

000000d8 <sixteen>:
	...

000000da <fifteen>:
	...

000000dc <fourteen>:
	...

000000de <thirteen>:
	...

000000e0 <twelve>:

	//24 cycles from beginning of interrupt (including 16 cycles of HFP and 8 cycles of active pixels)

	//beginning of Horizontal Sync Porch

	cbi _SFR_IO_ADDR(CONTROL_PORT), HSYNC_PIN ;2
  e0:	58 98       	cbi	0x0b, 0	; 11

	push r17 ;2
  e2:	1f 93       	push	r17
	push LINE_COUNTER_REGISTER_HIGH ;2
  e4:	df 93       	push	r29
	push LINE_COUNTER_REGISTER_LOW ;2
  e6:	cf 93       	push	r28
	lds LINE_COUNTER_REGISTER_HIGH, faf_lineCounterHigh ;2
  e8:	d0 91 05 01 	lds	r29, 0x0105	; 0x800105 <faf_lineCounterHigh>
	lds LINE_COUNTER_REGISTER_LOW, faf_lineCounterLow ;2
  ec:	c0 91 8a 04 	lds	r28, 0x048A	; 0x80048a <faf_lineCounterLow>
	//playing = true, new note = false, finish = true/false, enter = true: 50 cycles (+4) +
	//playing = true, new note = false, finish = true/false, enter = false: 42 cycles +6 (from difference in enter = true/false) = 48 (+6) -
	//playing = false, dont care: 19 cycles (+34) +

	//we play sound only on line 255 (lower value of line counter will go through 255 only once)
	ldi r16, 0xFF ;1
  f0:	0f ef       	ldi	r16, 0xFF	; 255
	cpse LINE_COUNTER_REGISTER_LOW, r16
  f2:	c0 13       	cpse	r28, r16
	jmp no_sound_update ;3
  f4:	0c 94 c3 00 	jmp	0x186	; 0x186 <no_sound_update>

	push r18 ;2
  f8:	2f 93       	push	r18
	push r19 ;2
  fa:	3f 93       	push	r19
	push r30 ;2
  fc:	ef 93       	push	r30
	push r31 ;2
  fe:	ff 93       	push	r31

	sbis _SFR_IO_ADDR(GENERAL_STATUS_REGISTER), GSR_IS_PLAYING_BIT ;1/3
 100:	f4 9b       	sbis	0x1e, 4	; 30
	rjmp after_sound_update_delay ;2
 102:	3b c0       	rjmp	.+118    	; 0x17a <after_sound_update_delay>

	//we are here after 11 cycles

	lds r16, faf_currentNoteFrame ;2
 104:	00 91 04 01 	lds	r16, 0x0104	; 0x800104 <faf_currentNoteFrame>
	lds r17, faf_noteDurationDivider ;2
 108:	10 91 00 01 	lds	r17, 0x0100	; 0x800100 <__data_start>
	lds r18, faf_currentNote ;2
 10c:	20 91 03 01 	lds	r18, 0x0103	; 0x800103 <faf_currentNote>
	lds r19, faf_notesCount ;2
 110:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__data_end>

	//19 cycles

	cp r16, r17 ;1
 114:	01 17       	cp	r16, r17
	breq next_note ;1/2
 116:	39 f0       	breq	.+14     	; 0x126 <next_note>
	...

	nop ;1
	nop ;1
	nop ;1

	rjmp after_next_note ;2
 124:	14 c0       	rjmp	.+40     	; 0x14e <after_next_note>

00000126 <next_note>:

next_note:

	clr r16 ;1
 126:	00 27       	eor	r16, r16
	inc r18 ;1
 128:	23 95       	inc	r18

	cp r18, r19 ;1
 12a:	23 17       	cp	r18, r19
	breq playing_finished ;1/2
 12c:	09 f0       	breq	.+2      	; 0x130 <playing_finished>
	rjmp after_next_note ;2
 12e:	0f c0       	rjmp	.+30     	; 0x14e <after_next_note>

00000130 <playing_finished>:
	...
	nop ;1

	nop ;1
	nop ;1

	clr r16 ;1
 140:	00 27       	eor	r16, r16
	sts _SFR_MEM_ADDR(TCCR2A), r16 ;2
 142:	00 93 b0 00 	sts	0x00B0, r16	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
	sts _SFR_MEM_ADDR(TCCR2B), r16 ;2
 146:	00 93 b1 00 	sts	0x00B1, r16	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
	cbi _SFR_IO_ADDR(GENERAL_STATUS_REGISTER), GSR_IS_PLAYING_BIT ;2
 14a:	f4 98       	cbi	0x1e, 4	; 30
	//no need to store not frame or note - just stop playing and exit
	rjmp after_sound_update ;2
 14c:	17 c0       	rjmp	.+46     	; 0x17c <after_sound_update>

0000014e <after_next_note>:

after_next_note:

	cpi r16, 0 ;1
 14e:	00 30       	cpi	r16, 0x00	; 0
	breq fill_in_new_note ;1/2
 150:	39 f0       	breq	.+14     	; 0x160 <fill_in_new_note>
	...

	nop ;1
	nop ;1
	nop ;1

	rjmp after_fill_in_new_note ;2
 15e:	07 c0       	rjmp	.+14     	; 0x16e <after_fill_in_new_note>

00000160 <fill_in_new_note>:

fill_in_new_note:

	ldi r30, lo8(faf_notes) ;1
 160:	eb e8       	ldi	r30, 0x8B	; 139
	ldi r31, hi8(faf_notes) ;1
 162:	f4 e0       	ldi	r31, 0x04	; 4

	//we do this only if r16 is 0
	add r30, r18 ;1
 164:	e2 0f       	add	r30, r18
	adc r31, r16 ;1
 166:	f0 1f       	adc	r31, r16

	ld r19, Z ;2
 168:	30 81       	ld	r19, Z
	sts _SFR_MEM_ADDR(OCR2A), r19 ;2
 16a:	30 93 b3 00 	sts	0x00B3, r19	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>

0000016e <after_fill_in_new_note>:

after_fill_in_new_note:

	inc r16 ;1
 16e:	03 95       	inc	r16

	sts faf_currentNote, r18 ;2
 170:	20 93 03 01 	sts	0x0103, r18	; 0x800103 <faf_currentNote>
	sts faf_currentNoteFrame, r16 ;2
 174:	00 93 04 01 	sts	0x0104, r16	; 0x800104 <faf_currentNoteFrame>
	rjmp after_sound_update ;2
 178:	01 c0       	rjmp	.+2      	; 0x17c <after_sound_update>

0000017a <after_sound_update_delay>:
	...

0000017c <after_sound_update>:
	//34 nops
	nop ;1

after_sound_update:

	pop r31 ;2
 17c:	ff 91       	pop	r31
	pop r30 ;2
 17e:	ef 91       	pop	r30
	pop r19 ;2
 180:	3f 91       	pop	r19
	pop r18 ;2
 182:	2f 91       	pop	r18

	rjmp sound_updated ;2
 184:	01 c0       	rjmp	.+2      	; 0x188 <sound_updated>

00000186 <no_sound_update>:
	...

00000188 <sound_updated>:

sound_updated:

	//69 cycles from beginning of HSP

	sbiw LINE_COUNTER_REGISTER_LOW, 2 ;2
 188:	22 97       	sbiw	r28, 0x02	; 2
	brcs turn_vsync_on ;1/2
 18a:	18 f0       	brcs	.+6      	; 0x192 <turn_vsync_on>
	nop ;1
 18c:	00 00       	nop
	sbi _SFR_IO_ADDR(CONTROL_PORT), VSYNC_PIN ;2
 18e:	59 9a       	sbi	0x0b, 1	; 11
	rjmp skip_turn_vsync_on ;2
 190:	03 c0       	rjmp	.+6      	; 0x198 <skip_turn_vsync_on>

00000192 <turn_vsync_on>:

turn_vsync_on:
	cbi _SFR_IO_ADDR(CONTROL_PORT), VSYNC_PIN ;2
 192:	59 98       	cbi	0x0b, 1	; 11
	nop ;1
 194:	00 00       	nop
	...

00000198 <skip_turn_vsync_on>:
	nop ;1

skip_turn_vsync_on:
	adiw LINE_COUNTER_REGISTER_LOW, 2 ;2
 198:	22 96       	adiw	r28, 0x02	; 2

	//79 cycles from beginning of HSP

	ldi r17, high(35) ;1
 19a:	10 e0       	ldi	r17, 0x00	; 0
	cpi LINE_COUNTER_REGISTER_LOW, low(35) ;1
 19c:	c3 32       	cpi	r28, 0x23	; 35
	cpc r17, LINE_COUNTER_REGISTER_HIGH ;1
 19e:	1d 07       	cpc	r17, r29
	breq turn_pixels_on ;1/2
 1a0:	11 f0       	breq	.+4      	; 0x1a6 <turn_pixels_on>
	nop ;1
 1a2:	00 00       	nop
	rjmp skip_turn_pixels_on ;2
 1a4:	01 c0       	rjmp	.+2      	; 0x1a8 <skip_turn_pixels_on>

000001a6 <turn_pixels_on>:

turn_pixels_on:
	sbi _SFR_IO_ADDR(GENERAL_STATUS_REGISTER), GSR_ACTIVE_PIXELS_BIT ;2
 1a6:	f0 9a       	sbi	0x1e, 0	; 30

000001a8 <skip_turn_pixels_on>:

skip_turn_pixels_on:
	
	//86 cycles from beginning of HSP

	ldi r17, high(415) ;1
 1a8:	11 e0       	ldi	r17, 0x01	; 1
	cpi LINE_COUNTER_REGISTER_LOW, low(415) ;1
 1aa:	cf 39       	cpi	r28, 0x9F	; 159
	cpc r17, LINE_COUNTER_REGISTER_HIGH ;1
 1ac:	1d 07       	cpc	r17, r29
	breq turn_pixels_off ;1/2
 1ae:	21 f0       	breq	.+8      	; 0x1b8 <turn_pixels_off>
	nop ;1
 1b0:	00 00       	nop
	nop ;1
 1b2:	00 00       	nop
	nop ;1
 1b4:	00 00       	nop
	rjmp skip_turn_pixels_off ;2
 1b6:	02 c0       	rjmp	.+4      	; 0x1bc <skip_turn_pixels_off>

000001b8 <turn_pixels_off>:

turn_pixels_off:
	cbi _SFR_IO_ADDR(GENERAL_STATUS_REGISTER), GSR_ACTIVE_PIXELS_BIT ;2
 1b8:	f0 98       	cbi	0x1e, 0	; 30
	sbi _SFR_IO_ADDR(GENERAL_STATUS_REGISTER), GSR_VBLANK_BIT ;2
 1ba:	f3 9a       	sbi	0x1e, 3	; 30

000001bc <skip_turn_pixels_off>:

skip_turn_pixels_off:

	nop ;1
 1bc:	00 00       	nop

	//96 cycles from beginning of HSP

	//horizontal back porch - 48 cycles

	sbi _SFR_IO_ADDR(CONTROL_PORT), HSYNC_PIN ;2
 1be:	58 9a       	sbi	0x0b, 0	; 11

	ldi r17, high(424) ;1
 1c0:	11 e0       	ldi	r17, 0x01	; 1
	cpi LINE_COUNTER_REGISTER_LOW, low(424) ;1
 1c2:	c8 3a       	cpi	r28, 0xA8	; 168
	cpc r17, LINE_COUNTER_REGISTER_HIGH ;1
 1c4:	1d 07       	cpc	r17, r29
	breq clear_line_counter ;1/2
 1c6:	29 f0       	breq	.+10     	; 0x1d2 <clear_line_counter>
	nop ;1
 1c8:	00 00       	nop
	nop ;1
 1ca:	00 00       	nop
	nop ;1
 1cc:	00 00       	nop
	adiw LINE_COUNTER_REGISTER_LOW, 1 ;2
 1ce:	21 96       	adiw	r28, 0x01	; 1
	rjmp skip_clear_line_counter ;2
 1d0:	06 c0       	rjmp	.+12     	; 0x1de <skip_clear_line_counter>

000001d2 <clear_line_counter>:

clear_line_counter:
	in r17, _SFR_IO_ADDR(GENERAL_STATUS_REGISTER) ;1
 1d2:	1e b3       	in	r17, 0x1e	; 30
	bst r17, GSR_NEW_BANK_BIT ;1
 1d4:	12 fb       	bst	r17, 2
	bld r17, GSR_CURRENT_BANK_BIT ;1
 1d6:	11 f9       	bld	r17, 1
	out _SFR_IO_ADDR(GENERAL_STATUS_REGISTER), r17 ;1
 1d8:	1e bb       	out	0x1e, r17	; 30
	clr LINE_COUNTER_REGISTER_LOW ;1
 1da:	cc 27       	eor	r28, r28
	clr LINE_COUNTER_REGISTER_HIGH	;1
 1dc:	dd 27       	eor	r29, r29

000001de <skip_clear_line_counter>:

	//STORE VALUES

	//CONTROL_DDR is always output - no need to store
	//CONTROL_PORT might be random so save it (i.e. OUTPUT_ENABLE_PIN pin usage during writing)
	in r17, _SFR_IO_ADDR(CONTROL_PORT) ;1
 1de:	1b b1       	in	r17, 0x0b	; 11
	push r17 ;2
 1e0:	1f 93       	push	r17

	//LOWER_ADDRESS_DDR is always output outside of interrupt - no need to store it (it is input only here)
	//LOWER_ADDRESS_PORT might be random so save it (i.e. during writing)
	in r16, _SFR_IO_ADDR(LOWER_ADDRESS_PORT) ;1
 1e2:	08 b1       	in	r16, 0x08	; 8
	push r16 ;2
 1e4:	0f 93       	push	r16
	
	//HIGHER_ADDRESS_DDR is always output - no need to store, only 1 pin is overriden as input when in SPI mode
	//HIGHER_ADDRESS_PORT might be random so save it (i.e. during writing)
	in r16, _SFR_IO_ADDR(HIGHER_ADDRESS_PORT) ;1
 1e6:	05 b1       	in	r16, 0x05	; 5
	push r16 ;2
 1e8:	0f 93       	push	r16

	//DATA_DDR is always output - no need to store, set as input only here during reading
	//DATA_PORT might be random so save it (i.e. during writing)
	in r16, _SFR_IO_ADDR(DATA_PORT) ;1
 1ea:	02 b1       	in	r16, 0x02	; 2
	push r16 ;2
 1ec:	0f 93       	push	r16
	//we do not touch HSYNC_PIN
	//we do not touch VSYNC_PIN
	//we set PERIPHERAL_ENABLE_PIN to disable for now (we will turn it on after we set all ports as input), it should be turned off anyway but whatever
	//we do not touch SOUND_PIN
	//we deselect NETWORK_ENABLE_PIN, it should be turned off anyway but whatever
	ori r17, (1<<BANK_SWITCH_PIN | 1<<WRITE_READ_ENABLE_PIN | 1<<OUTPUT_ENABLE_PIN | 1<<PERIPHERAL_ENABLE_PIN | 1<<NETWORK_ENABLE_PIN) ;1
 1ee:	1c 6b       	ori	r17, 0xBC	; 188
	out _SFR_IO_ADDR(CONTROL_PORT), r17 ;1
 1f0:	1b b9       	out	0x0b, r17	; 11

	//set port as input with pull-ups, before we open controller buffer
	ldi r16, 0x00 ;1
 1f2:	00 e0       	ldi	r16, 0x00	; 0
	out _SFR_IO_ADDR(LOWER_ADDRESS_DDR), r16 ;1
 1f4:	07 b9       	out	0x07, r16	; 7
	ldi r17, 0xFF ;1
 1f6:	1f ef       	ldi	r17, 0xFF	; 255
	out _SFR_IO_ADDR(LOWER_ADDRESS_PORT), r17 ;1
 1f8:	18 b9       	out	0x08, r17	; 8

	//set port as output with all ones for now, before we open sd buffer; no need to change DDR
	out _SFR_IO_ADDR(HIGHER_ADDRESS_PORT), r17 ;1
 1fa:	15 b9       	out	0x05, r17	; 5

	

	//now we enable all peripherals
	in r17, _SFR_IO_ADDR(CONTROL_PORT) ;1
 1fc:	1b b1       	in	r17, 0x0b	; 11
	andi r17, ~(1<<PERIPHERAL_ENABLE_PIN) ;1
 1fe:	1f 7d       	andi	r17, 0xDF	; 223
	out _SFR_IO_ADDR(CONTROL_PORT), r17 ;1
 200:	1b b9       	out	0x0b, r17	; 11


	//READ INPUT

	in r16, CONTROLLER_PIN ;1
 202:	06 b5       	in	r16, 0x26	; 38
	out _SFR_IO_ADDR(CONTROLLER_STATUS_REGISTER), r16 ;1
 204:	0a bd       	out	0x2a, r16	; 42

	

	sbis _SFR_IO_ADDR(_SFR_IO_ADDR(CONTROL_PORT)), GSR_ACTIVE_PIXELS_BIT ;1/3
 206:	58 9b       	sbis	0x0b, 0	; 11
	rjmp no_video ;2
 208:	30 c0       	rjmp	.+96     	; 0x26a <no_video>

0000020a <video>:
video:	

	//38 cycles from beginning of HBP

	//now we disable all peripherals
	ori r17, (1<<PERIPHERAL_ENABLE_PIN) ;1
 20a:	10 62       	ori	r17, 0x20	; 32
	out _SFR_IO_ADDR(CONTROL_PORT), r17 ;1
 20c:	1b b9       	out	0x0b, r17	; 11

	//do not change data port for now
	//no need to chage higher address

	//now we turn lower back to being output
	ldi r16, 0xFF ;1
 20e:	0f ef       	ldi	r16, 0xFF	; 255
	out _SFR_IO_ADDR(LOWER_ADDRESS_DDR), r16 ;1
 210:	07 b9       	out	0x07, r16	; 7
	out _SFR_IO_ADDR(LOWER_ADDRESS_PORT), r16 ;1
 212:	08 b9       	out	0x08, r16	; 8

	//set port as floating input, to protect from short-circuit when we do reading
	ldi r16, 0 ;1
 214:	00 e0       	ldi	r16, 0x00	; 0
	out _SFR_IO_ADDR(DATA_DDR), r16 ;1
 216:	01 b9       	out	0x01, r16	; 1
	out _SFR_IO_ADDR(DATA_PORT), r16 ;1
 218:	02 b9       	out	0x02, r16	; 2
	//46 cycles from beginning of HBP
	//horizontal active pixels - 640 cycles

	//we copy new_bank_bit to current_bank_bit at the beginning of each frame, then we test this value to determine
	//if we should use bank 0 or 1 
	sbic _SFR_IO_ADDR(GENERAL_STATUS_REGISTER), GSR_CURRENT_BANK_BIT ;1/2 
 21a:	f1 99       	sbic	0x1e, 1	; 30
	andi r17, ~(1<<BANK_SWITCH_PIN) ;1
 21c:	17 7f       	andi	r17, 0xF7	; 247
	out _SFR_IO_ADDR(CONTROL_PORT), r17 ;1
 21e:	1b b9       	out	0x0b, r17	; 11


	//TODO make sure we increment line counter in good place
	//we divide line counter by 2, to doulbe each line and display 240 lines
	mov r16, LINE_COUNTER_REGISTER_LOW ;1
 220:	0c 2f       	mov	r16, r28
	lsr r16 ;1
 222:	06 95       	lsr	r16
	cpi LINE_COUNTER_REGISTER_HIGH, 0x01 ;1
 224:	d1 30       	cpi	r29, 0x01	; 1
	brne highest_bit_not_set ;1/2
 226:	09 f4       	brne	.+2      	; 0x22a <highest_bit_not_set>
	ori r16, 0b10000000 ;1
 228:	00 68       	ori	r16, 0x80	; 128

0000022a <highest_bit_not_set>:

highest_bit_not_set:

	out _SFR_IO_ADDR(HIGHER_ADDRESS_PORT), r16 ;1
 22a:	05 b9       	out	0x05, r16	; 5
	ldi r16, 0 ;1
 22c:	00 e0       	ldi	r16, 0x00	; 0
	out _SFR_IO_ADDR(LOWER_ADDRESS_PORT), r16 ;1
 22e:	08 b9       	out	0x08, r16	; 8

	//starting read will open video buffer
	andi r17, ~(1<<WRITE_READ_ENABLE_PIN | 1<<OUTPUT_ENABLE_PIN) ;1
 230:	1b 7e       	andi	r17, 0xEB	; 235

	//12 cycles from beginning of HAP

	out _SFR_IO_ADDR(CONTROL_PORT), r17 ;1
 232:	1b b9       	out	0x0b, r17	; 11
	
	//256 pixels wide = 512 cycles, which leaves us with 128 cycles to do something else (64 on each end)
	inc r16
 234:	03 95       	inc	r16
	out _SFR_IO_ADDR(LOWER_ADDRESS_PORT), r16 ;1
 236:	08 b9       	out	0x08, r16	; 8
	inc r16
 238:	03 95       	inc	r16
	out _SFR_IO_ADDR(LOWER_ADDRESS_PORT), r16 ;1
 23a:	08 b9       	out	0x08, r16	; 8

	//256 pixels sent
	
	//we stop reading (that will close video buffer) and outputting data
	ori r17, (1<<WRITE_READ_ENABLE_PIN | 1<<OUTPUT_ENABLE_PIN)
 23c:	14 61       	ori	r17, 0x14	; 20
	out _SFR_IO_ADDR(CONTROL_PORT), r17
 23e:	1b b9       	out	0x0b, r17	; 11

	//return data port to output, we not have any data left on RAM pins as we disabled output
	ldi r16, 0xFF
 240:	0f ef       	ldi	r16, 0xFF	; 255
	out _SFR_IO_ADDR(DATA_DDR), r16
 242:	01 b9       	out	0x01, r16	; 1

	//restore all saved/changed data
	pop r16
 244:	0f 91       	pop	r16
	out _SFR_IO_ADDR(DATA_PORT), r16
 246:	02 b9       	out	0x02, r16	; 2
	pop r16 ;2
 248:	0f 91       	pop	r16
	out _SFR_IO_ADDR(HIGHER_ADDRESS_PORT), r16 ;1
 24a:	05 b9       	out	0x05, r16	; 5
	pop r16 ;2
 24c:	0f 91       	pop	r16
	out _SFR_IO_ADDR(LOWER_ADDRESS_PORT), r16 ;1
 24e:	08 b9       	out	0x08, r16	; 8
	pop r16 ;2
 250:	0f 91       	pop	r16
	out _SFR_IO_ADDR(CONTROL_PORT), r16 ;1
 252:	0b b9       	out	0x0b, r16	; 11

	sts faf_lineCounterLow, LINE_COUNTER_REGISTER_LOW ;2
 254:	c0 93 8a 04 	sts	0x048A, r28	; 0x80048a <faf_lineCounterLow>
	sts faf_lineCounterHigh, LINE_COUNTER_REGISTER_HIGH ;2
 258:	d0 93 05 01 	sts	0x0105, r29	; 0x800105 <faf_lineCounterHigh>
	pop LINE_COUNTER_REGISTER_LOW ;2
 25c:	cf 91       	pop	r28
	pop LINE_COUNTER_REGISTER_HIGH ;2
 25e:	df 91       	pop	r29
	pop r17 ;2
 260:	1f 91       	pop	r17
	pop r16 ;2
 262:	0f 91       	pop	r16
	out _SFR_IO_ADDR(SREG), r16 ;1
 264:	0f bf       	out	0x3f, r16	; 63
	pop r16 ;2
 266:	0f 91       	pop	r16

	reti ;4-5 ?
 268:	18 95       	reti

0000026a <no_video>:
	//38 cycles from beginning of HBP
	
	//do some reading and writing to SPI here

	//now we disable all peripherals
	ori r17, (1<<PERIPHERAL_ENABLE_PIN)
 26a:	10 62       	ori	r17, 0x20	; 32
	out _SFR_IO_ADDR(CONTROL_PORT), r17
 26c:	1b b9       	out	0x0b, r17	; 11

	//do not change data port for now
	//no need to chage higher address

	//now we turn lower back to being output
	ldi r16, 0xFF
 26e:	0f ef       	ldi	r16, 0xFF	; 255
	out _SFR_IO_ADDR(LOWER_ADDRESS_DDR), r16
 270:	07 b9       	out	0x07, r16	; 7
	out _SFR_IO_ADDR(LOWER_ADDRESS_PORT), r16
 272:	08 b9       	out	0x08, r16	; 8

	//restore all saved/changed data
	pop r16
 274:	0f 91       	pop	r16
	out _SFR_IO_ADDR(DATA_PORT), r16
 276:	02 b9       	out	0x02, r16	; 2
	pop r16 ;2
 278:	0f 91       	pop	r16
	out _SFR_IO_ADDR(HIGHER_ADDRESS_PORT), r16 ;1
 27a:	05 b9       	out	0x05, r16	; 5
	pop r16 ;2
 27c:	0f 91       	pop	r16
	out _SFR_IO_ADDR(LOWER_ADDRESS_PORT), r16 ;1
 27e:	08 b9       	out	0x08, r16	; 8
	pop r16 ;2
 280:	0f 91       	pop	r16
	out _SFR_IO_ADDR(CONTROL_PORT), r16 ;1
 282:	0b b9       	out	0x0b, r16	; 11


	sts faf_lineCounterLow, LINE_COUNTER_REGISTER_LOW ;2
 284:	c0 93 8a 04 	sts	0x048A, r28	; 0x80048a <faf_lineCounterLow>
	sts faf_lineCounterHigh, LINE_COUNTER_REGISTER_HIGH ;2
 288:	d0 93 05 01 	sts	0x0105, r29	; 0x800105 <faf_lineCounterHigh>
	pop LINE_COUNTER_REGISTER_LOW ;2
 28c:	cf 91       	pop	r28
	pop LINE_COUNTER_REGISTER_HIGH ;2
 28e:	df 91       	pop	r29
	pop r17 ;2
 290:	1f 91       	pop	r17
	pop r16 ;2
 292:	0f 91       	pop	r16
	out _SFR_IO_ADDR(SREG), r16 ;1
 294:	0f bf       	out	0x3f, r16	; 63
	pop r16 ;2
 296:	0f 91       	pop	r16

 298:	18 95       	reti

0000029a <initPorts>:
#include <avr\io.h>
#include "fafbox.h"


void initPorts(void) {
	CONTROL_DDR = 0xFF;
 29a:	8f ef       	ldi	r24, 0xFF	; 255
 29c:	8a b9       	out	0x0a, r24	; 10
	CONTROL_PORT = (1<<HSYNC_PIN | 1<<VSYNC_PIN | 1<<WRITE_READ_ENABLE_PIN | 1<<BANK_SWITCH_PIN | 1<<PERIPHERAL_ENABLE_PIN | 1<<OUTPUT_ENABLE_PIN | 0<<SOUND_PIN | 1<<NETWORK_ENABLE_PIN);
 29e:	9f eb       	ldi	r25, 0xBF	; 191
 2a0:	9b b9       	out	0x0b, r25	; 11
	
	LOWER_ADDRESS_DDR = 0xFF;
 2a2:	87 b9       	out	0x07, r24	; 7
	LOWER_ADDRESS_PORT = 0x00;
 2a4:	18 b8       	out	0x08, r1	; 8
	HIGHER_ADDRESS_DDR = 0xFF;
 2a6:	84 b9       	out	0x04, r24	; 4
	HIGHER_ADDRESS_PORT = 0x00;
 2a8:	15 b8       	out	0x05, r1	; 5
	DATA_DDR = 0xFF;
 2aa:	81 b9       	out	0x01, r24	; 1
	DATA_PORT = 0x00;
 2ac:	12 b8       	out	0x02, r1	; 2
	
	GENERAL_STATUS_REGISTER = 0x00;
 2ae:	1e ba       	out	0x1e, r1	; 30
	CONTROLLER_STATUS_REGISTER = 0xFF; //no input
 2b0:	8a bd       	out	0x2a, r24	; 42
 2b2:	08 95       	ret

000002b4 <initVideo>:

/*
	Method used to init video procedure. It sets up Timer1 with appropriate values and starts timer (although no video will be rendered until we set GLOBAL_INTERRUPT_ENABLE flag with sei()).
*/
void initVideo() {
	TCCR1A = 0;
 2b4:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
	TCCR1B = (1<<CS10) | (1<<WGM12);
 2b8:	89 e0       	ldi	r24, 0x09	; 9
 2ba:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	OCR1AH = high(800);
 2be:	83 e0       	ldi	r24, 0x03	; 3
 2c0:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
	OCR1AL = low(800);
 2c4:	80 e2       	ldi	r24, 0x20	; 32
 2c6:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	TIMSK1 = (1<<OCIE1A);
 2ca:	82 e0       	ldi	r24, 0x02	; 2
 2cc:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
 2d0:	08 95       	ret

000002d2 <main>:
#include "fafbox.h"
#include "graphics.h"


int main(void) {
    initPorts();
 2d2:	0e 94 4d 01 	call	0x29a	; 0x29a <initPorts>
	initVideo();
 2d6:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <initVideo>
	sei();
 2da:	78 94       	sei

    while (1) {
    }
 2dc:	ff cf       	rjmp	.-2      	; 0x2dc <main+0xa>

000002de <_exit>:
 2de:	f8 94       	cli

000002e0 <__stop_program>:
 2e0:	ff cf       	rjmp	.-2      	; 0x2e0 <__stop_program>
